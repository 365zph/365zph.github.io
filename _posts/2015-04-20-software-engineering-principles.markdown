---
author: viviworld
comments: true
date: 2015-04-20 23:08:48+00:00
excerpt: 编写优秀代码。使用一个代码库服务（假定不是非常敏感的数据），比如 GitHub 或 Bitbucket。给了你代码库、问题追踪和轻松做代码审查的能力。配置一台服务器，编译你的代码库、运行测试，一天至少一次。
layout: post
link: http://www.labazhou.net/2015/04/software-engineering-principles/
slug: software-engineering-principles
title: 软件工程原则
wordpress_id: 1891
categories:
- 编程
- 软件
tags:
- Bitbucket
- bug
- github
- Jenkins
- 代码
- 代码审查
- 单元测试
- 程序员
- 编译器
---


	
  * 原文地址（original source）：[http://robohub.org/software-engineering-principles/](http://robohub.org/software-engineering-principles/)

	
  * 作者（author）：[https://twitter.com/DavidKohanbash](https://twitter.com/DavidKohanbash)





* * *



我经常思考，对于我在开发的各种机器人而言，合适的软件方法论应该是什么样子。我的想法随着时间的推移而演化，我看到了它们的作用。由于我没有受过正式的软件工程培训，这些都是我曾经看到过、听到过、阅读过的通用原则，我深信不疑（我写到这里，已经是凌晨 2 点了）。

_免责：大多数建议来自其它资源。请查看附加的链接以查看详情。_

既然写代码是最基础的，我就从如何编写代码开始。然后我们进入软件工程基础，它需要让软件合理地运转。


### 通用编程规则


在编码时，如果没有基本规则供你遵循，你的代码注定要失败且不可依赖。其它工作都基于此。很多人开始编程，想使用疯狂的模板魔法，每个地方都继承其它某些地方，然而，你必须停下来，编写易于理解和测试的简单代码。



	
  * **控制结构简单**------限制你的分支，不要有长长的 if-else 嵌套、循环语句，不要有递归魔法。

	
  * **无限循环**------如果你不是真想永远困在那儿，就不要使用没有边际的循环（比如主循环）。必须有一个上/下边界用于终止循环。loop 循环要比 while 循环更要慎重。

	
  * **没有动态内存**------忘了 `malloc` 的存在。它能够引起程序在每次运行时有着不同的行为，还能增加内存泄露，这是难以检测到的。

	
  * **断言**【注1】------断言有助于你实施、对每个函数有帮助的、合适的事情。我通常不喜欢默认的断言函数，它们只是简单地引起一个终止；有时候这是合适的，但是对于大部分情况，你应该尝试从错误中恢复而非只是终止。你需要评估在你的应用程序中，什么才是更安全的方式。

	
  * **保持作用域**------尽量在一个尽可能小的范围内赋值或初始化变量、结构等。这包括了限制全局变量的使用。

	
  * **指针**------有可能时，要限制你的指针使用。你应该真正避免多级指针。如果你引用了不应该接触的内存地址，它们追踪起来将非常混乱，且导致各种问题。

	
  * **检查来自所有（非 `void`）函数的返回值**------如果一个函数能够（应该能够）返回错误的值，请确保捕获它并做相应处理。检查返回值的边界而非盲目地相信它，也是不错的。

	
  * **打开所有的编译器警告**------这样你能尽早捕获一些情况。对于格式化文本、内存相关以及位拆裂【注2】，尤为重要。

	
  * **使用圆括号控制运行顺序**------我见过很多人臆测或忘记了操作符的正确顺序。使用圆括号可以澄清和加强想要的结果。

	
  * **硬编码数字**------请为任何值使用变量，它可能需要被另一名程序员修改。如果你有一个非常不明显的数字，要就该数字的来源以及如何派生写个注释。

	
  * **预处理器**------限制预处理器为“简单的”东东，比如 `#define` 和 `#if`。使用复杂的宏将导致难以理解的代码、难以移植、和 bug 增加的几率。

	
  * **标准**------使你的代码保持一致性。这包含命名、空格、你的花括号放在哪里。这使得沿用代码变得容易。如果你编辑已有代码，就使用已有代码的风格。

	
  * **当心循环中的 NOOP 【注3】或 empty**------它们应该被避免，因为它们在不同的系统运行方式不同。这主要是针对嵌入式系统的。

	
  * **给你的代码写文档**------需要我说更多吗？


**有帮助的链接**：



	
  * [Rules for defensive C programming](http://www.eetindia.co.in/ARTICLES/1999DEC/PDF/EEIOL_1999DEC01_EMS_TA_1.pdf)

	
  * [The Power of Ten – Rules for Developing Safety Critical Code](http://spinroot.com/gerard/pdf/P10.pdf)




### 软件代码库


对于每个程序员和编程团队而言，拥有一个代码库是必须的。有很多可用的免费工具，因此没有理由不用它们。

有了软件代码库，你就用在各个点保存代码，你就能回滚都先前的工作版本。代码库还让你在每个文件记录修改了什么、被谁修改了的日志。这些工具是和团队分享代码的优秀方式------没有必要来来回回用邮件发送代码。你还能把文档放入代码库，这样它就一直是可用的。

有很多可选项，cvs、svn、mercurial、git、bitkeeper 等。挑一个！

最近我在用一种托管的代码库服务，名叫 github.com------我喜欢与这个网站上的 git 打包的所有工具。bitbucket.org 是另一个类似选择。

我通常喜欢在根目录下按照如下目录创建代码库：



	
  * **bin**------所有二进制文件编译后放置的地方。默认情况下，这个目录不应该签入代码库。

	
  * **config**------如果有很多 config 文件，我把它们都放在这个目录。

	
  * **doc**------系统文档（数据表、图表、笔记等）

	
  * **externals**------来自于外部的源代码和资源库（比如，你不想编写它们了）

	
  * **includes**------多个程序想在编译时访问的头文件。

	
  * **libs**------所有资源库编译之后存放的地方。默认情况下，这个文件夹也不要签入代码库。

	
  * **src**------这里应该是我们写代码的地方。

	
  * **tools**------不适用于其它地方的、比较随意的“工具”。


除了以上目录，我通常把项目的主 make file 和 README 放在根目录。

**链接**：



	
  * [Software repositories or just plain repo](http://robotsforroboticists.com/repos/)




### Bug/问题追踪


用一个中央数据库追踪 bug，对于开发没有 bug 的优秀代码是非常重要的。任何人发现了 bug，用这种方式来报告，就不会丢失。仅仅告诉开发人员或给他们发邮件是不够的。人们忘性大。理想情况下，你不想让开发人员关闭 bug；你想让某人报告 bug，开发人员修复它，然后发现该 bug 的那个人确认它被正确地修复了。

一个 bug 报告需要三个条件：



	
  1. 你期望发生什么

	
  2. 实际发生了什么

	
  3. 重现可观察到的行为（比如 bug）的步骤。尽量最小化需要重现错误的步骤数。包括你在用的代码版本。


**链接**：



	
  * [Painless Bug Tracking](http://www.joelonsoftware.com/articles/fog0000000029.html)




### 自动化测试


你的每个过程/函数都应该有一组测试（经常叫做“单元测试”）以验证它们的功能。这些测试确保函数能够应付各种输入极端和组合。理想情况下，你应该针对一个函数内的每种可能控制提供测试。

比如，如果你在测试函数“`sum(number1, number2)`”，可以有下列测试文件：

    
    int main () {
      assert( 2 = sum(1,1));
      assert( 0 = sum(-1,1));
      assert( NULL = sum(1,NULL)); // or whatever you want it to be doing…
      assert( 0 = sum(0,0));
      assert( 1999998 = sum(999999,999999));
      assert( 5 = sum(4.2,1)); // assuming integers and that floats are rounded.
    
      RETURN (TRUE);
    }


在这个例子中，断言将要在失败和终止的地方打印出错误信息。（这只是我的小例子，一定可以被扩展和改善。它还可以修改为在编译时失败，这样你就无需“运行”它了。）


### 自动化（每天）构建系统


拥有一台构建服务器，在有人提交代码、或最小化地、每个晚上时构建，对于识别引入系统的不经意的 bug 和自动化运行测试，是非常有价值的。

你对一个模块做了修改，经常引起另一个模块的失败。但是作为开发人员，我们聚焦于我们的模块，倾向于尽量不重新编译所有代码来确保我们没有破坏其它地方。早些发现你搞坏的地方，常常是更好的。

某些修改倾向于让其它模块破坏更多的模块。例如，修改一个使用广泛的头文件或消息定义文件，会引起其它问题。

它还让程序员仅把编译好的代码提交到代码库而不破坏代码。如果他们提交了有问题的代码，构建工具可以/应该发送邮件，通知人们这次构建失败了（以及这是谁的错误）。

你可以弄一个快速脚本来签出代码库、构建、分析输出和邮件发送结果；也可以找一个合适的构建系统，比如 Jenkins。通常地，使用其他人的产品更加可靠，也可以有效利用你的时间。

**链接**：



	
  * [Daily Builds Are Your Friend](http://www.joelonsoftware.com/articles/fog0000000023.html)




### 代码审查


代码审查是艰难的，但是[它们也是减少代码中 bug 数量的最好办法](http://www.labazhou.net/2015/01/increase-defect-detection-with-our-code-review-checklist-example/)。传统的代码审核------会议室里一个人站起来和其他人讨论所有代码（这个人从没见过该代码）------**不会起作用**！让人们熟悉程序的运行或许是有好处的，但是这不是代码审查和找到问题的最好办法。

为了做代码审查，你应该让该程序员给 1-3 名其他软件工程师发送审查请求。这个审查请求应该包含代码总览、流程图和访问代码的说明。工程师的数量和他们的经验应该符合代码的关键程度。每个参与审查的人应该是：



	
  1. 审查代码（比较明显）------不要拘泥于形式，你要珍惜自己的时间。

	
  2. 整理一份关于代码的问题清单。

	
  3. 编写一些测试，确保他们通过了（它们可以被提交，常常运行在每日构建）。


在一次大型审查之前的代码审查时，审查者应该关注的地方有：

	
  * 代码做了它应该做的事情吗（不要做它不应该做的）？

	
  * 代码/函数应该用更有效的方式编写吗？

	
  * 控制流程是简单/整洁/优秀的吗（`if`、`else`、`return` 等）？

	
  * `switch` 语句有默认的 `catch` 来捕获所有异常吗？

	
  * 代码注释够多吗？

	
  * 变量是在合适的作用域内（最小化全局）声明的吗？

	
  * 有内存泄露吗？

	
  * 如果返回了 NULL，会发生什么？

	
  * 错误/异常处理

	
  * 缓冲区溢出（用 `char`、`int` 等做不合适的事情，内存位置）

	
  * 指针和基于 math 的指针

	
  * 数组索引

	
  * 关闭所有句柄（文件、端口等）

	
  * 宏的使用

	
  * 64 位和 32 位的修正

	
  * 多线程（有必要？线程数量、计分点、死锁、数据传递、优先级倒置等）

	
  * 操作符（优先级和正确的用法[&和&&、=和==]）

	
  * 来自用户和函数的输入项在使用之前是否检查了


（上面的这个清单和优秀编程实践有些类似，你注意到了吗？）

做了上面步骤后，就可以组织一次大会，人们坐下来，通读和审查代码；虽然这不是严格必需的。

审查代码应该是艰难的。让你的程序员习惯阅读代码和审查代码，有助于加强他们自己的编码。设置一名专门的 QA 人员审查代码也是有用的。

**链接**：



	
  * [Embedded System Code Review Checklist](http://betterembsw.blogspot.com/2011/11/embedded-system-code-review-checklist.html)

	
  * [Microsoft: Best Practices: Code Reviews](https://msdn.microsoft.com/en-us/library/bb871031.aspx)




### 编译系统


你应该使用一种编译工具，而不用手动编译每个文件。很可能最常用的工具是 make。

每个 make 文件应该至少有如下指令：



	
  * **all**------编译所有的生产代码（production code）

	
  * **clean**------删除二进制和目标文件。使得下一次编译是完全干净的。

	
  * **install**------把二进制和资源库安装到正确的路径。这可以是如下的过程：

	
    * 拷贝旧的二进制文件到 <binaryName>_<archivedDateTime>

	
    * 拷贝新的二进制文件到带有活动进程的位置。




	
  * **test**------编译一组单元/系统测试，校验操作，确认没有引入 bug。


我相信，你应该能用一个命令来编译、安装、测试或清理你的整个系统了。正常情况下，我将为每个进程生成一个 make 文件，然后创建一个主 make 文件，来调用所有单独的 make 文件。让一个单个 make 文件编译所有文件，有利于安装新系统，也使得配置每日构建更加容易。


### 总结





	
  * 编写优秀代码。

	
  * 使用一个代码库服务（假定不是非常敏感的数据），比如 GitHub 或 Bitbucket。给了你代码库、问题追踪和轻松做代码审查的能力。

	
  * 配置一台服务器，编译你的代码库、运行测试，一天至少一次。


为了让你的软件更加可靠，你还有其它喜爱的工具吗？请在下面留言。



* * *






	
  * 注1：在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果－当程序运行到断言的位置时，对应的断言应该为真。若断言不会真时，程序会中止运行，并出现错误消息。[http://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)](http://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F))

	
  * 注2：位拆裂 (Bit Banging)：一种利用微控制器的通用端口仿真串行接口标准(I²C、SPI等)的技术。[http://en.wikipedia.org/wiki/Bit_banging](http://en.wikipedia.org/wiki/Bit_banging)

	
  * 注3：计算机科学中，NOP或NOOP（No Operation或No Operation Performed的缩写，意为无操作）是汇编语言的一个指令，一系列编程语句，或网络传输协议中的表示不做任何有效操作的命令。[http://zh.wikipedia.org/wiki/NOP](http://zh.wikipedia.org/wiki/NOP)


